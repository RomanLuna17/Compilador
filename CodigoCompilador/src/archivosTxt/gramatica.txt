/*NOTA: estas son las tareas asignadas:6 7 10 13 18 19 21 26 29 33 35

Lo que hice fue tomar la gramatica de los chicos y sacar los errores y dejar lo que creo que vamos a usar pero estoy bastante seguro que tiene errores.
Dentro de la gramatica de los chicos (simon, labo y valen) yo llegue hasta la linea 332
*/
       //declaracion de tokens a recibir del Analizador Lexico
%token ID CTE CADENA IF ELSE END_IF PRINT FUNC RETURN WHILE DO
 LONG ASSIGN COMP_MAYOR_IGUAL COMP_MENOR_IGUAL COMP_IGUAL COMP_DISTINTO
 LOGIC_AND LOGIC_OR VOID IGUAL_DOS_PUNTOS

%left '+' '-'
%left '*' '/'

%start program

%%

//gramatica del lenguaje

program: programa
       ;

programa: nombre_programa '{' bloque_sentencias_programa '}'
        ;

nombre_programa: ID 
	       ;

bloque_sentencias_programa: bloque_sentencias_programa sentencia_programa
        		              | sentencia_programa
        		              ;

sentencia_programa: sentencias_declarativas
        	        | sentencias_ejecutables
		              ;

sentencias_declarativas:  declaracion_variables ','
        	             | declaracion_funciones
                       | declaracion_clase
                        | sentencia_declarativa_con_asignacion ',' {System.out.println("Linea "+ AnalizadorLexico.getLineaActual() + ", Se reconocio la asignacion a una variable " +  $1.sval);}
		       ;

sentencia_declarativa_con_asignacion: tipo ID igual_dos_puntos valor_asignacion
				    ;

sentencias_ejecutables: sentencia_asignacion ','
                      | sentencia_seleccion ','
                      | sentencia_out ','
                      | sentencia_control ','
                      | sentencia_discard ','
                      ;

declaracion_variables: tipo list_var
		     ;

tipo: I16 {System.out.println("Linea: "+ AnalizadorLexico.getLineaActual() + ", Se reconocio el tipo I16");
	   $$.sval = "i16";
	   aux = "i16";}
    | F32 {System.out.println("Linea: "+ AnalizadorLexico.getLineaActual() + ", Se reconocio el tipo F32");
    	   $$.sval = "f32";
    	   aux = "f32";}
    | CADENA {System.out.println("Linea: "+ AnalizadorLexico.getLineaActual() + ", Se reconocio una cadena");
    	      aux = "CADENA";}
    ;

list_var: list_var ',' ID {//TablaDeSimbolos.agregarSimbolo($2.sval, ambito.toString());
          System.out.println("G86: se le va a asignar tipo: " + aux + " a la variable " + $3.sval + ambito);
          TablaDeSimbolos.obtenerSimbolo($3.sval, ambito.toString()).setTipo(aux);
          TablaDeSimbolos.obtenerSimbolo($3.sval, ambito.toString()).setUso("variable");}
        | ID {//TablaDeSimbolos.agregarSimbolo($1.sval, ambito.toString());
          System.out.println("G90: se le va a asignar tipo: " + aux + " a la variable " + $1.sval + ambito);
          TablaDeSimbolos.obtenerSimbolo($1.sval, ambito.toString()).setTipo(aux);
          TablaDeSimbolos.obtenerSimbolo($1.sval, ambito.toString()).setUso("variable");}
	;

declaracion_clase: ID '{' sentencias_clase '}'



declaracion_funciones: tipo_funcion header_funcion '(' parametro ')' '{' cuerpo_funcion '}'  
        	           | tipo_funcion header_funcion '(' ')' '{' cuerpo_funcion '}'
		                  ;

tipo_funcion: ':' tipo {TablaDeSimbolos.obtenerSimbolo(ambito.substring(ambito.lastIndexOf(".")+1) + ambito.substring(0, ambito.lastIndexOf("."))).setTipo($2.sval);
			$$.sval = $2.sval;}
	    ;

header_funcion: FUN ID {System.out.println("Linea: "+ AnalizadorLexico.getLineaActual() + ", Se reconocio la declaracion de la funcion " + $2.sval);
                        cambiarAmbito($2.sval);
                        pila.push(polaca.size());
                        polaca.agregarAPolaca("");
                        polaca.agregarAPolaca("#BI");
                        TablaDeSimbolos.agregarSimbolo("LABEL" + polaca.size());
                        polaca.agregarAPolaca("LABEL" + polaca.size());
                        polaca.agregarAPolaca($2.sval);
                        polaca.agregarAPolaca("#INICIO");
                        TablaDeSimbolos.obtenerSimbolo($2.sval, ambito.substring(0, ambito.lastIndexOf("."))).setUso("nombre funcion");
                        }
	      ;

parametro: tipo ID {System.out.println("Linea: "+ AnalizadorLexico.getLineaActual() + ", Se reconocio el parametro " + $2.sval);
		     //TablaDeSimbolos.agregarSimbolo($2.sval, ambito.toString());
		     System.out.println("G182 obtener simbolo con: "+$2.sval+ ambito.toString());
		     TablaDeSimbolos.obtenerSimbolo($2.sval, ambito.toString()).setTipo(aux);
		     TablaDeSimbolos.obtenerSimbolo($2.sval, ambito.toString()).setUso("parametro declaracion");}
	 ;



cuerpo_funcion: bloque_sentencias_ejecutables_return
	      ;

bloque_sentencias_ejecutables_return: bloque_sentencias_ejecutables_return sentencia_ejecutable_return
				    | bloque_sentencias_ejecutables_return sentencias_declarativas
				    | sentencia_ejecutable_return
				    | sentencias_declarativas
				    ;

sentencia_ejecutable_return: sentencia_asignacion ','
			   | sentencia_seleccion_return ','
			   | sentencia_out ','
			   | sentencia_control_return ','
			   | sentencia_retorno ','
			   ;

sentencia_retorno: RETURN '(' expr_aritmetic ')' {System.out.println("Linea: "+ AnalizadorLexico.getLineaActual() + ", Se reconocio una sentencia de retorno");
						  String lexema = TablaDeSimbolos.obtenerSimbolo($3.sval, ambito.toString()).getLexema();
              					  polaca.agregarAPolaca("#RETURN");
              					  pilaReturn.push(polaca.size());
              					  tipoReturn.push(lexema);
						  polaca.agregarAPolaca("");
						  polaca.agregarAPolaca("#BI");
              TablaDeSimbolos.agregarSimbolo("LABEL" + polaca.size());
              polaca.agregarAPolaca("LABEL" + polaca.size());
						  //if(!chequeoTipo(ambito.substring(ambito.lastIndexOf(".")+1),$3.sval)) Lo realizo al reconocer funcion
                                                  	//{ agregarError(ConstantesCompilador.ERROR, ConstantesCompilador.SINTACTICO, "tipo de return incompatible");}
						  }
		 | RETURN '(' invocacion_funcion ')' {System.out.println("Linea: "+ AnalizadorLexico.getLineaActual() + ", Se reconocio una sentencia de retorno");
		 				      String lexema = TablaDeSimbolos.obtenerSimbolo($2.sval, ambito.toString()).getLexema();
                                                      polaca.agregarAPolaca("#RETURN");
                                                      pilaReturn.push(polaca.size());
                                                      tipoReturn.push(lexema);
		 				      polaca.agregarAPolaca("");
                                                      polaca.agregarAPolaca("#BI");
                                                      TablaDeSimbolos.agregarSimbolo("LABEL" + polaca.size());
                                                      polaca.agregarAPolaca("LABEL" + polaca.size());
                                                      }
		 ;

sentencia_asignacion: ID igual_dos_puntos valor_asignacion {System.out.println("Linea: "+ AnalizadorLexico.getLineaActual() + ", Se reconocio la asignacion a la variable " + $1.sval);
							    chequeoAmbito($1.sval, ambito.toString());
							    polaca.agregarAPolaca($1.sval);
							    if((! tipoBreak.isEmpty()) && (asignacionDo)){
							    	while(! tipoBreak.isEmpty()){
                                                                   String tbreak = tipoBreak.pop();
                                                                   if(!chequeoTipo($1.sval , tbreak)){
                                                                   	agregarError(ConstantesCompilador.ERROR, ConstantesCompilador.SINTACTICO, "Error en asignacion, tipos incompatibles en el break");
                                                                   }
                                                                }
                                                                asignacionDo = false;
                                                                polaca.agregarAPolaca("#DOEX");
                                                            ;} else {
								if(!chequeoTipo($1.sval , $3.sval)){
									agregarError(ConstantesCompilador.ERROR, ConstantesCompilador.SINTACTICO, "Error en asignacion, tipos incompatibles");
								}
							    };
							    polaca.agregarAPolaca($2.sval);}
		    ;

igual_dos_puntos: IGUAL_DOS_PUNTOS {ultimaAsignacion = polaca.size();}
		;

valor_asignacion: expr_aritmetic
		| invocacion_funcion
		| sentencia_control {asignacionDo = true;}
		;

sentencia_seleccion: IF '(' condicion ')' '{' bloque_ejecutable '}'  end_if 
		                | IF '(' condicion ')' '{' bloque_ejecutable '}'  else '{' bloque_ejecutable '}' end_if
                   ;



else: ELSE 
;

end_if: END_IF 
;


//SIGO DESDE ACA
condicion: expr_aritmetic '>' expr_aritmetic {System.out.println("Linea: "+ AnalizadorLexico.getLineaActual() + ", Se reconocio la condicion de comparacion por mayor");
					      polaca.agregarAPolaca($2.sval);
					      pila.push(polaca.size());
					      polaca.agregarAPolaca("");
                                              polaca.agregarAPolaca("#BF");
                                              }
         | expr_aritmetic '<' expr_aritmetic {System.out.println("Linea: "+ AnalizadorLexico.getLineaActual() + ", Se reconocio la condicion de comparacion por menor");
         				      polaca.agregarAPolaca($2.sval);
         				      pila.push(polaca.size());
         				      polaca.agregarAPolaca("");
                                              polaca.agregarAPolaca("#BF");
                                              }
		·······························
         | expr_aritmetic '==' expr_aritmetic {System.out.println("Linea: "+ AnalizadorLexico.getLineaActual() + ", Se reconocio la condicion de comparacion por igualdad");
                  			      polaca.agregarAPolaca($2.sval);
                  			      pila.push(polaca.size());
                  			      polaca.agregarAPolaca("");
                                              polaca.agregarAPolaca("#BF");
                                              }
         | expr_aritmetic MAYOR_IGUAL expr_aritmetic {System.out.println("Linea: "+ AnalizadorLexico.getLineaActual() + ", Se reconocio la condicion de comparacion por mayor o igual");
                  			              polaca.agregarAPolaca($2.sval);
                  			              pila.push(polaca.size());
                  			              polaca.agregarAPolaca("");
                                                      polaca.agregarAPolaca("#BF");
                                                	}      
			························
         | expr_aritmetic  MENOR_IGUAL expr_aritmetic {System.out.println("Linea: "+ AnalizadorLexico.getLineaActual() + ", Se reconocio la condicion de comparacion por menor o igual");
                  			      	       polaca.agregarAPolaca($2.sval);
                  			      	       pila.push(polaca.size());
                  			      	       polaca.agregarAPolaca("");
                                                       polaca.agregarAPolaca("#BF");
                                                       }
	 | expr_aritmetic (VER)EXCLAMACION_EXCLAMACION expr_aritmetic {System.out.println("Linea: "+ AnalizadorLexico.getLineaActual() + ", Se reconocio la condicion de comparacion por distinto");
                  			      		    polaca.agregarAPolaca($2.sval);
                  			      		    pila.push(polaca.size());
                  			      		    polaca.agregarAPolaca("");
                                                            polaca.agregarAPolaca("#BF");}     
	 ;

bloque_ejecutable:  bloque_ejecutable sentencias_ejecutables
		 | bloque_ejecutable sentencias_declarativas
                 | sentencias_ejecutables
                 | sentencias_declarativas
                 ;

sentencia_out: OUT '(' CADENA ')' {System.out.println("Linea: "+ AnalizadorLexico.getLineaActual() + ", Se reconocio la impresion de una cadena: "+$3.sval);
				   polaca.agregarAPolaca($3.sval);
				   polaca.agregarAPolaca($1.sval);}
             ;





FIN DE GRAMATICA. COMIENZO DE FUNCIONES
%%
public static void ConstanteNegativa(String lexema){
  	Simbolo s = TablaDeSimbolos.obtenerSimbolo(lexema);
        String tipo = s.getTipo();
        TablaDeSimbolos.agregarSimbolo('-'+lexema, ConstantesCompilador.CONSTANTE);
        TablaDeSimbolos.obtenerSimbolo('-'+lexema).setUso("constante");
        TablaDeSimbolos.obtenerSimbolo('-'+lexema).setTipo(tipo);
   }

      public static void ConstantePositiva(String lexema){
        if (! lexema.contains(".")) {
          if (Integer.parseInt(lexema) > ConstantesCompilador.MAX_INT_POSITIVO) {
            Parser.agregarError(ConstantesCompilador.WARNING, ConstantesCompilador.LEXICO, "El numero es demasiado grande. Se lo ha reemplazado por el mas cercano posible: " + ConstantesCompilador.MAX_INT_POSITIVO);
            lexema = String.valueOf(ConstantesCompilador.MAX_INT_POSITIVO);
          }
        }
        TablaDeSimbolos.obtenerSimbolo(lexema).setUso("constante");
      }

      public static boolean sentencia_control = false;
      public static List<String> errores = new ArrayList<>();
      public static  List<String> warnings = new ArrayList<>();

      int yylex() throws IOException {

        int identificador_token = 0;
        Reader lector = compilador.AnalizadorLexico.lector;
        compilador.AnalizadorLexico.estado_actual = 0;
        while (! EOF(lector)) {
          char caracter = nextChar(lector);
          identificador_token = AnalizadorLexico.proximoEstado(lector, caracter);
          if (identificador_token != ConstantesCompilador.EN_LECTURA) {
            yylval = new ParserVal(AnalizadorLexico.getTokenActual());
            AnalizadorLexico.token_actual.delete(0, AnalizadorLexico.token_actual.length());
            return identificador_token;
          }
        }
        return identificador_token;
      }

      public static char nextChar(Reader reader) throws IOException {
        reader.mark(1);
        char next_char = (char) reader.read();
        reader.reset();
        return next_char;
      }

      
      private boolean EOF(Reader lector) throws IOException {
        lector.mark(1);
        int value = lector.read();
        lector.reset();
        return value == -1;
      }
